### TCP协议

特点：面向连接的、字节流、可靠传输

使用TCP协议通信双方必须建立连接，然后才能开始数据的读写。TCP连接是全双工的，即双方的数据读写可以通过一个连接进行。完成数据交换之后，通信双方都必须断开连接以释放系统资源。

 字节流和数据报服务的区别：

在编程中具体体现为通信双方是否必须执行相同次数的读 、写操作。当发送端发送数据时候，TCP模块将这些数据放入TCP缓冲区，当真正开始发送数据时，发送缓冲区中这些等待发送的数据就可能被封装成一个或多个TCP报文段发出。因此TCP模块发送出的报文段的个数和应用程序的写操作次数之间没有固定的数量关系。

当接收端收到一个或多个TCP报文段后，TCP模块将他们携带的应用程序数据按照TCP报文段序号依次放入TCP接受缓冲区，并通知应用程序读取数据。接收端应用程序可以一次性将TCP接收缓冲区中的数据全部读出，也可以分多次读取。所以，读操作和TCP模块接收的TCP报文段个数之间没有固定的数量关系。

综上：发送端执行的写操作次数和接收端执行的读操作次数之间没有任何数量关系，这就是字节流的概念：应用程序对数据的发送和接受是没有边界限制的。

UDP：发送端每执行一次写操作，UDP模块就将其封装成一个UDP数据并发送。接收端必须及时针对每一个UDP数据报执行读操作，否则就会丢包。

![image-20211203152548711](C:\Users\mzx\AppData\Roaming\Typora\typora-user-images\image-20211203152548711.png)

这是他们之间的一个区别

#### TCP连接和关闭

连接就三次握手过程，关闭就三次挥手过程

三次握手过程主要就

**半关闭状态**

TCP连接是全双工的，所以允许两个方向的数据传输被独立关闭。 通信的一端可以发送结束报文段给对方，告诉它本端已经完成了数据的发送，但允许继续接受来自对方的数据，知道对方也发送结束报文段以关闭连接。

这种状态被称为半关闭状态。socket编程中使用shutdown函数提供半关闭支持。

#### TCP状态转移过程

**服务器端**

* 通过listen调用进入LISTEN状态，等待客户端连接，
* 服务器一旦建通道某个连接请求，就将该连接放入内核等待队列中，并向客户端发送带SYN标志的确认报文段，此时进入SYN_RCVD状态。
* 如果服务器成功接受到客户端发送的确认报文段，则该连接状态转移到ESTABLISHED状态。就是可以进行双向数据传输的状态。
* 当客户端主动关闭连接时，服务器通过返回确认报文段使列检进入CLOSE_WAIT状态，即等待服务器应用程序关闭连接。
* 使连接状态转移到LAST_ACK状态，等待客户端最后一次确认，一旦确认完成，连接就彻底关闭

**客户端**

* 通过connect系统调用主动与服务器建立连接。connect系统调用首先给服务器发送一个同步报文段，使连接转移状态到SYN_SENT状态。
  * 如果connect连接的目标端口不存在，或该端口被处于TIME_WAIT状态的连接所占用，则服务器给客户端发送一个复位报文段，connect调用失败
  * 如果目标端口存在，但connect在超时时间内未收到确认报文段，则connect调用失败
* connect调用失败将使连接立即返回到初始CLOSED状态。如果客户端成功收到服务器的同步报文段和确认，则connect调用成功返回，连接转移ESTABLISHED状态。
* 当客户端执行主动关闭时，将向服务器发送一个结束报文段，同时连接进入FIN_WAIT1状态。
* 收到服务器的确认报文段之后，连接转移至FIN_WAIT2状态。此时服务器处于CLOSED_WAIT状态。此时服务器也关闭连接，则客户端给与确认并进入TIME_WAIT状态。

![image-20211205165443939](C:\Users\mzx\AppData\Roaming\Typora\typora-user-images\image-20211205165443939.png)

#### 带外数据

传输层协议具有带外数据，用于迅速通告对方本端发生的重要事件。因此带外数据比普通数据更高的优先级，它应该总是被立即发送，而不论发送缓冲区中是否有排队等待发送的普通数据。

udp没有实现带歪数据传输，TCP是利用其头部中的紧急指针标志和紧急指针两个字段，给应用程序提供一种紧急方式。TCP的紧急方式利用传输普通数据的连接来传输紧急数据。

#### TCP超时重传

TCP服务必须能够重传超时时间内未收到确认的TCP报文段。为此，TCP模块为每个TCP报文段都维护一个重传定时器，该定时器在TCP报文段第一次被发送时启动。如果超时时间内未收到接收方的应答，TCP模块将重传TCP报文段并重置定时器。

#### TCP拥塞控制

拥塞控制的最终受控变量是发送端向网络一次连续写入的数据量成为SWND（发送窗口）发送端最终以TCP报文段来发送数据，所以SWND限定了发送端能连续发送TCP报文段数量。发送窗口太小，会引起网络延迟，太大会导致网络拥塞。

**慢启动和拥塞避免**

TCP连接建立好之后，CWND将被设置成初始值IW（initial window），其大小为2-4个smss（最大长度）。此后每收到接收端一个确认，CWND就按照 CWND+=min(N,SMSS),增加，N是此次确认中包含的之前未被确认的字节数。

TCP刚开始发送数据时并不知道网络的实际情况，需要一种试探的方式平滑的增加CWND大小。

但是必须的增加手段，不能使得CWND很快膨胀并导致网络拥塞。因此定义了一个状态变量：慢启动门限。当CWND的大小超过该值，TCP拥塞控制将进入拥塞避免阶段。

拥塞避免算法使得CWND按照线性方式增加，从而减缓其扩大。

拥塞发生判断依据：

* 传输超时，或者说TCP重传定时器溢出：使用慢启动和拥塞避免
* 接受到重复的确认报文段:这种情况使用快速重传和快速恢复。

**快速重传和快速恢复**

发送端可能接收到重复的确认报文段，比如TCP报文段丢失，或者接收端收到乱序TCP报文段并重排、拥塞控制算法需要判断当收到重复的确认报文段时，网络是否真的发生了拥塞，或者说TCP报文段是否真的丢失了。

具体做法是连续收到三个重复的确认报文段，就认为是拥塞发生了，然后他启用快速重传和快速恢复

* 当收到重复确认报文段时，立即重传丢失的报文段，并重新设置CWND
* 每次收到一个重复的确认时，设置CWND=CWND+SMSS。此时发送端可以发送新的TCP报文段
* 当收到新数据的确认时，设置CWND=sshresh（是新的慢启动门限值）

快速重传和快速恢复完成之后，拥塞控制恢复到拥塞避免阶段